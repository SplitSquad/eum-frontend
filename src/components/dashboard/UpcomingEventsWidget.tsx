import React, { useState, useEffect } from 'react';
import {
  Paper,
  Box,
  Typography,
  List,
  ListItem,
  ListItemText,
  ListItemIcon,
  Avatar,
  Chip,
  IconButton,
  Divider,
  Button,
  CircularProgress,
  Dialog,
  DialogTitle,
  DialogContent,
  DialogActions,
  TextField,
  FormControl,
  InputLabel,
  Select,
  MenuItem,
  Menu,
  ListItemButton,
  Snackbar,
  Alert,
  AlertTitle,
  useTheme,
  useMediaQuery,
} from '@mui/material';
import EventIcon from '@mui/icons-material/Event';
import CalendarTodayIcon from '@mui/icons-material/CalendarToday';
import AccessTimeIcon from '@mui/icons-material/AccessTime';
import LocationOnIcon from '@mui/icons-material/LocationOn';
import PersonIcon from '@mui/icons-material/Person';
import RefreshIcon from '@mui/icons-material/Refresh';
import AddIcon from '@mui/icons-material/Add';
import SyncIcon from '@mui/icons-material/Sync';
import GoogleIcon from '@mui/icons-material/Google';
import EditIcon from '@mui/icons-material/Edit';
import DeleteIcon from '@mui/icons-material/Delete';
import MoreVertIcon from '@mui/icons-material/MoreVert';
import SaveIcon from '@mui/icons-material/Save';
import CancelIcon from '@mui/icons-material/Cancel';
import LockIcon from '@mui/icons-material/Lock';
import ExpandMoreIcon from '@mui/icons-material/ExpandMore';
import { widgetPaperBase, widgetGradients } from './theme/dashboardWidgetTheme';
import CalendarService, {
  CalendarEvent,
  GoogleCalendarEventRequest,
} from '../../services/calendar/calendarService';

// Ïù¥Î≤§Ìä∏ Ìèº Îç∞Ïù¥ÌÑ∞ ÌÉÄÏûÖ
interface EventFormData {
  summary: string;
  description: string;
  location: string;
  startDate: string;
  startTime: string;
  endDate: string;
  endTime: string;
  category: string;
}

// Ïù¥Î≤§Ìä∏ ÌÉÄÏûÖÎ≥Ñ ÏÉâÏÉÅ - Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî Ïù¥Î≤§Ìä∏Îäî ÌÉÄÏûÖÏù¥ ÏóÜÏúºÎØÄÎ°ú Ïù¥Î¶Ñ Í∏∞Î∞òÏúºÎ°ú ÏûÑÏùò Î∂ÑÎ•ò
const getEventTypeColor = (summary: string) => {
  if (summary.includes('ÌöåÏùò') || summary.includes('ÎØ∏ÌåÖ') || summary.includes('meeting')) {
    return { bg: 'rgba(33, 150, 243, 0.1)', color: '#2196F3', icon: 'üë•' };
  } else if (
    summary.includes('Î≥¥Í≥†') ||
    summary.includes('Ï†úÏ∂ú') ||
    summary.includes('ÎßàÍ∞ê') ||
    summary.includes('deadline')
  ) {
    return { bg: 'rgba(244, 67, 54, 0.1)', color: '#F44336', icon: '‚è∞' };
  } else if (
    summary.includes('Ï§ëÏöî') ||
    summary.includes('ÌïÑÏàò') ||
    summary.includes('important')
  ) {
    return { bg: 'rgba(156, 39, 176, 0.1)', color: '#9C27B0', icon: '‚≠ê' };
  } else if (summary.includes('Ïó¨Ìñâ') || summary.includes('Ï∂úÏû•') || summary.includes('travel')) {
    return { bg: 'rgba(76, 175, 80, 0.1)', color: '#4CAF50', icon: '‚úàÔ∏è' };
  } else if (summary.includes('ÌïôÏäµ') || summary.includes('Í≥µÎ∂Ä') || summary.includes('study')) {
    return { bg: 'rgba(255, 152, 0, 0.1)', color: '#FF9800', icon: 'üìö' };
  } else {
    return { bg: 'rgba(96, 125, 139, 0.1)', color: '#607D8B', icon: 'üìå' };
  }
};

// Ïö∞ÏÑ†ÏàúÏúÑ Í≥ÑÏÇ∞ (ÏãúÍ∞ÑÏù¥ Í∞ÄÍπåÏö∏ÏàòÎ°ù ÎÜíÏùÄ Ïö∞ÏÑ†ÏàúÏúÑ)
const calculatePriority = (event: CalendarEvent): 'high' | 'medium' | 'low' => {
  if (!event.start?.dateTime) return 'low';

  const eventDate = new Date(event.start.dateTime);
  const now = new Date();
  const diffHours = (eventDate.getTime() - now.getTime()) / (1000 * 60 * 60);

  if (diffHours <= 24) return 'high';
  if (diffHours <= 72) return 'medium';
  return 'low';
};

// ÎÇ†Ïßú Ìè¨Îß∑ÌåÖ Ìï®Ïàò
const formatDate = (dateString: string): string => {
  const date = new Date(dateString);
  const today = new Date();
  const tomorrow = new Date(today);
  tomorrow.setDate(tomorrow.getDate() + 1);

  const isToday = date.toDateString() === today.toDateString();
  const isTomorrow = date.toDateString() === tomorrow.toDateString();

  if (isToday) return 'Ïò§Îäò';
  if (isTomorrow) return 'ÎÇ¥Ïùº';

  const diffTime = date.getTime() - today.getTime();
  const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

  if (diffDays <= 7) {
    return `${diffDays}Ïùº ÌõÑ`;
  }

  return date.toLocaleDateString('ko-KR', {
    month: 'short',
    day: 'numeric',
    weekday: 'short',
  });
};

// ÏãúÍ∞Ñ Ìè¨Îß∑ÌåÖ Ìï®Ïàò
const formatTime = (dateString: string): string => {
  const date = new Date(dateString);
  return date.toLocaleTimeString('ko-KR', {
    hour: '2-digit',
    minute: '2-digit',
    hour12: false,
  });
};

interface EventItemProps {
  event: CalendarEvent;
  onEdit: (event: CalendarEvent) => void;
  onDelete: (eventId: string) => void;
}

const EventItem: React.FC<EventItemProps> = ({ event, onEdit, onDelete }) => {
  const [anchorEl, setAnchorEl] = useState<null | HTMLElement>(null);
  const eventConfig = getEventTypeColor(event.summary);
  const priority = calculatePriority(event);

  // Ïö∞ÏÑ†ÏàúÏúÑÎ≥Ñ ÏÉâÏÉÅ
  const priorityColors = {
    high: '#F44336',
    medium: '#FF9800',
    low: '#4CAF50',
  };

  const handleMenuOpen = (event: React.MouseEvent<HTMLElement>) => {
    event.stopPropagation();
    setAnchorEl(event.currentTarget);
  };

  const handleMenuClose = () => {
    setAnchorEl(null);
  };

  const handleEdit = () => {
    onEdit(event);
    handleMenuClose();
  };

  const handleDelete = () => {
    onDelete(event.id);
    handleMenuClose();
  };

  return (
    <>
      <ListItem
        sx={{
          px: 0,
          py: 1.5,
          borderRadius: 2,
          '&:hover': {
            bgcolor: 'action.hover',
            cursor: 'pointer',
          },
          transition: 'background-color 0.2s ease',
        }}
      >
        <ListItemIcon sx={{ minWidth: 48 }}>
          <Avatar
            sx={{
              bgcolor: eventConfig.bg,
              color: eventConfig.color,
              width: 40,
              height: 40,
              fontSize: '1.2rem',
            }}
          >
            {eventConfig.icon}
          </Avatar>
        </ListItemIcon>

        <ListItemText
          primary={
            <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
              <Typography variant="subtitle2" fontWeight={600} sx={{ flex: 1, mr: 1 }}>
                {event.summary}
              </Typography>
              <Box
                sx={{
                  width: 8,
                  height: 8,
                  borderRadius: '50%',
                  bgcolor: priorityColors[priority],
                  ml: 1,
                }}
              />
            </Box>
          }
          secondary={
            <Box>
              {/* ÎÇ†ÏßúÏôÄ ÏãúÍ∞Ñ */}
              <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                <CalendarTodayIcon sx={{ fontSize: 14, mr: 0.5, color: 'text.secondary' }} />
                <Typography variant="caption" color="text.secondary">
                  {formatDate(event.start.dateTime)}
                </Typography>
                {event.start.dateTime && (
                  <>
                    <AccessTimeIcon sx={{ fontSize: 12, mx: 0.5, color: 'text.secondary' }} />
                    <Typography variant="caption" color="text.secondary">
                      {formatTime(event.start.dateTime)}
                    </Typography>
                  </>
                )}
              </Box>

              {/* ÏúÑÏπò */}
              {event.location && (
                <Box sx={{ display: 'flex', alignItems: 'center', mb: 0.5 }}>
                  <LocationOnIcon sx={{ fontSize: 14, mr: 0.5, color: 'text.secondary' }} />
                  <Typography variant="caption" color="text.secondary">
                    {event.location}
                  </Typography>
                </Box>
              )}

              {/* Ï£ºÏµúÏûê */}
              {event.organizer?.displayName && (
                <Box sx={{ display: 'flex', alignItems: 'center' }}>
                  <PersonIcon sx={{ fontSize: 14, mr: 0.5, color: 'text.secondary' }} />
                  <Typography variant="caption" color="text.secondary">
                    {event.organizer.displayName}
                  </Typography>
                </Box>
              )}
            </Box>
          }
        />

        <IconButton size="small" onClick={handleMenuOpen} sx={{ ml: 1 }}>
          <MoreVertIcon fontSize="small" />
        </IconButton>
      </ListItem>

      <Menu
        anchorEl={anchorEl}
        open={Boolean(anchorEl)}
        onClose={handleMenuClose}
        anchorOrigin={{
          vertical: 'bottom',
          horizontal: 'right',
        }}
        transformOrigin={{
          vertical: 'top',
          horizontal: 'right',
        }}
      >
        <MenuItem onClick={handleEdit}>
          <EditIcon sx={{ mr: 1, fontSize: 18 }} />
          ÏàòÏ†ï
        </MenuItem>
        <MenuItem onClick={handleDelete} sx={{ color: 'error.main' }}>
          <DeleteIcon sx={{ mr: 1, fontSize: 18 }} />
          ÏÇ≠Ï†ú
        </MenuItem>
      </Menu>
    </>
  );
};

// Ïù¥Î≤§Ìä∏ Ï∂îÍ∞Ä/ÏàòÏ†ï Îã§Ïù¥ÏñºÎ°úÍ∑∏
interface EventDialogProps {
  open: boolean;
  onClose: () => void;
  onSave: (eventData: EventFormData) => void;
  event?: CalendarEvent | null;
  isLoading?: boolean;
}

const EventDialog: React.FC<EventDialogProps> = ({
  open,
  onClose,
  onSave,
  event,
  isLoading = false,
}) => {
  const [formData, setFormData] = useState<EventFormData>({
    summary: '',
    description: '',
    location: '',
    startDate: '',
    startTime: '',
    endDate: '',
    endTime: '',
    category: 'general',
  });

  // Ïù¥Î≤§Ìä∏ Îç∞Ïù¥ÌÑ∞Î°ú Ìèº Ï¥àÍ∏∞Ìôî
  useEffect(() => {
    if (event) {
      const startDate = new Date(event.start.dateTime);
      const endDate = new Date(event.end?.dateTime || event.start.dateTime);

      setFormData({
        summary: event.summary || '',
        description: event.description || '',
        location: event.location || '',
        startDate: startDate.toISOString().split('T')[0],
        startTime: startDate.toTimeString().slice(0, 5),
        endDate: endDate.toISOString().split('T')[0],
        endTime: endDate.toTimeString().slice(0, 5),
        category: 'general',
      });
    } else {
      // ÏÉà Ïù¥Î≤§Ìä∏Ïùò Í≤ΩÏö∞ Í∏∞Î≥∏Í∞í ÏÑ§Ï†ï
      const now = new Date();
      const oneHourLater = new Date(now.getTime() + 60 * 60 * 1000);

      setFormData({
        summary: '',
        description: '',
        location: '',
        startDate: now.toISOString().split('T')[0],
        startTime: now.toTimeString().slice(0, 5),
        endDate: oneHourLater.toISOString().split('T')[0],
        endTime: oneHourLater.toTimeString().slice(0, 5),
        category: 'general',
      });
    }
  }, [event, open]);

  const handleInputChange =
    (field: keyof EventFormData) =>
    (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
      setFormData(prev => ({
        ...prev,
        [field]: e.target.value,
      }));
    };

  const handleSave = () => {
    if (!formData.summary.trim()) return;
    onSave(formData);
  };

  return (
    <Dialog
      open={open}
      onClose={onClose}
      maxWidth="sm"
      fullWidth
      PaperProps={{
        sx: { borderRadius: 3 },
      }}
    >
      <DialogTitle sx={{ pb: 1 }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <EventIcon sx={{ mr: 1, color: 'primary.main' }} />
          {event ? 'ÏùºÏ†ï ÏàòÏ†ï' : 'ÏÉà ÏùºÏ†ï Ï∂îÍ∞Ä'}
        </Box>
      </DialogTitle>

      <DialogContent sx={{ pt: 2 }}>
        <Box sx={{ display: 'flex', flexDirection: 'column', gap: 2 }}>
          <TextField
            label="Ï†úÎ™©"
            value={formData.summary}
            onChange={handleInputChange('summary')}
            fullWidth
            required
            variant="outlined"
          />

          <TextField
            label="ÏÑ§Î™Ö"
            value={formData.description}
            onChange={handleInputChange('description')}
            fullWidth
            multiline
            rows={2}
            variant="outlined"
          />

          <TextField
            label="ÏúÑÏπò"
            value={formData.location}
            onChange={handleInputChange('location')}
            fullWidth
            variant="outlined"
          />

          <Box sx={{ display: 'flex', gap: 2 }}>
            <TextField
              label="ÏãúÏûë ÎÇ†Ïßú"
              type="date"
              value={formData.startDate}
              onChange={handleInputChange('startDate')}
              fullWidth
              InputLabelProps={{ shrink: true }}
            />
            <TextField
              label="ÏãúÏûë ÏãúÍ∞Ñ"
              type="time"
              value={formData.startTime}
              onChange={handleInputChange('startTime')}
              fullWidth
              InputLabelProps={{ shrink: true }}
            />
          </Box>

          <Box sx={{ display: 'flex', gap: 2 }}>
            <TextField
              label="Ï¢ÖÎ£å ÎÇ†Ïßú"
              type="date"
              value={formData.endDate}
              onChange={handleInputChange('endDate')}
              fullWidth
              InputLabelProps={{ shrink: true }}
            />
            <TextField
              label="Ï¢ÖÎ£å ÏãúÍ∞Ñ"
              type="time"
              value={formData.endTime}
              onChange={handleInputChange('endTime')}
              fullWidth
              InputLabelProps={{ shrink: true }}
            />
          </Box>

          <FormControl fullWidth>
            <InputLabel>Ïπ¥ÌÖåÍ≥†Î¶¨</InputLabel>
            <Select
              value={formData.category}
              onChange={e => setFormData(prev => ({ ...prev, category: e.target.value }))}
              label="Ïπ¥ÌÖåÍ≥†Î¶¨"
            >
              <MenuItem value="general">ÏùºÎ∞ò</MenuItem>
              <MenuItem value="meeting">ÌöåÏùò</MenuItem>
              <MenuItem value="important">Ï§ëÏöî</MenuItem>
              <MenuItem value="travel">Ïó¨Ìñâ</MenuItem>
              <MenuItem value="study">ÌïôÏäµ</MenuItem>
            </Select>
          </FormControl>
        </Box>
      </DialogContent>

      <DialogActions sx={{ p: 2, pt: 1 }}>
        <Button onClick={onClose} startIcon={<CancelIcon />} disabled={isLoading}>
          Ï∑®ÏÜå
        </Button>
        <Button
          onClick={handleSave}
          variant="contained"
          startIcon={<SaveIcon />}
          disabled={!formData.summary.trim() || isLoading}
          sx={{ borderRadius: 2 }}
        >
          {isLoading ? <CircularProgress size={20} /> : event ? 'ÏàòÏ†ï' : 'Ï∂îÍ∞Ä'}
        </Button>
      </DialogActions>
    </Dialog>
  );
};

const UpcomingEventsWidget: React.FC = () => {
  const [events, setEvents] = useState<CalendarEvent[]>([]);
  const [isLoading, setIsLoading] = useState(true);
  const [isGoogleConnected, setIsGoogleConnected] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [dialogOpen, setDialogOpen] = useState(false);
  const [editingEvent, setEditingEvent] = useState<CalendarEvent | null>(null);
  const [isDialogLoading, setIsDialogLoading] = useState(false);

  // OAuth Î°úÍ∑∏Ïù∏ ÏÉÅÌÉú Ï≤¥ÌÅ¨ Ï∂îÍ∞Ä
  const [isOAuthUser, setIsOAuthUser] = useState(false);
  const [userProfile, setUserProfile] = useState<any>(null);

  const [snackbar, setSnackbar] = useState<{
    open: boolean;
    message: string;
    severity: 'success' | 'error';
  }>({
    open: false,
    message: '',
    severity: 'success',
  });

  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));
  const [isCollapsed, setIsCollapsed] = useState(false);

  // OAuth ÏÇ¨Ïö©Ïûê Ï≤¥ÌÅ¨ Ìï®Ïàò Ï∂îÍ∞Ä
  const checkOAuthUser = () => {
    try {
      // Î°úÏª¨ Ïä§ÌÜ†Î¶¨ÏßÄÏóêÏÑú ÏÇ¨Ïö©Ïûê Ï†ïÎ≥¥ ÌôïÏù∏
      const token = localStorage.getItem('token');
      const userInfo = localStorage.getItem('userInfo');

      if (token && userInfo) {
        const parsedUserInfo = JSON.parse(userInfo);
        setUserProfile(parsedUserInfo);

        // OAuth Ï†úÍ≥µÏûêÍ∞Ä ÏûàÎäîÏßÄ ÌôïÏù∏ (Google OAuth)
        // ÎòêÎäî Ïù¥Î©îÏùºÏù¥ GmailÏù∏ÏßÄ ÌôïÏù∏
        const isGoogleOAuth =
          parsedUserInfo.provider === 'google' ||
          parsedUserInfo.email?.includes('@gmail.com') ||
          parsedUserInfo.oauth_provider === 'google';

        setIsOAuthUser(isGoogleOAuth);

        if (isGoogleOAuth) {
          checkGoogleCalendarConnection();
        } else {
          setIsLoading(false);
        }
      } else {
        setIsOAuthUser(false);
        setIsLoading(false);
      }
    } catch (error) {
      console.error('OAuth ÏÇ¨Ïö©Ïûê ÌôïÏù∏ Ïã§Ìå®:', error);
      setIsOAuthUser(false);
      setIsLoading(false);
    }
  };

  // Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî Ïó∞Îèô ÏÉÅÌÉú ÌôïÏù∏
  const checkGoogleCalendarConnection = async () => {
    try {
      const isConnected = await CalendarService.checkGoogleCalendarConnection();
      setIsGoogleConnected(isConnected);
      if (isConnected) {
        await fetchEvents();
      }
    } catch (error) {
      console.error('Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî Ïó∞Îèô ÏÉÅÌÉú ÌôïÏù∏ Ïã§Ìå®:', error);
      setIsGoogleConnected(false);
      setError('Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî Ïó∞Îèô ÌôïÏù∏Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
    } finally {
      setIsLoading(false);
    }
  };

  // Ï∫òÎ¶∞Îçî Ïù¥Î≤§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞
  const fetchEvents = async () => {
    setIsLoading(true);
    setError(null);
    try {
      const calendarEvents = await CalendarService.getEvents();

      // Îã§Í∞ÄÏò§Îäî Ïù¥Î≤§Ìä∏Îßå ÌïÑÌÑ∞ÎßÅ (Ïò§ÎäòÎ∂ÄÌÑ∞ ÏïûÏúºÎ°ú 30ÏùºÍ∞Ñ)
      const now = new Date();
      const thirtyDaysLater = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);

      const upcomingEvents = calendarEvents
        .filter(event => {
          if (!event.start?.dateTime) return false;
          const eventDate = new Date(event.start.dateTime);
          return eventDate >= now && eventDate <= thirtyDaysLater;
        })
        .sort((a, b) => {
          const dateA = new Date(a.start.dateTime);
          const dateB = new Date(b.start.dateTime);
          return dateA.getTime() - dateB.getTime();
        })
        .slice(0, 10); // ÏµúÎåÄ 10Í∞úÎßå ÌëúÏãú

      setEvents(upcomingEvents);
    } catch (error) {
      console.error('Ï∫òÎ¶∞Îçî Ïù¥Î≤§Ìä∏ Í∞ÄÏ†∏Ïò§Í∏∞ Ïã§Ìå®:', error);
      setError('ÏùºÏ†ïÏùÑ Î∂àÎü¨Ïò§ÎäîÎç∞ Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      setEvents([]);
    } finally {
      setIsLoading(false);
    }
  };

  // Ïª¥Ìè¨ÎÑåÌä∏ ÎßàÏö¥Ìä∏ Ïãú Îç∞Ïù¥ÌÑ∞ Î°úÎî©
  useEffect(() => {
    // OAuth ÏÇ¨Ïö©Ïûê Ï≤¥ÌÅ¨ Î®ºÏ†Ä Ïã§Ìñâ
    checkOAuthUser();
  }, []);

  // ÏÉàÎ°úÍ≥†Ïπ® Ìï∏Îì§Îü¨
  const handleRefresh = () => {
    checkGoogleCalendarConnection();
  };

  // Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî ÎèôÍ∏∞Ìôî Ìï∏Îì§Îü¨
  const handleGoogleSync = async () => {
    setIsLoading(true);
    try {
      await fetchEvents();
      showSnackbar('Ï∫òÎ¶∞ÎçîÍ∞Ä ÎèôÍ∏∞ÌôîÎêòÏóàÏäµÎãàÎã§.', 'success');
    } catch (error) {
      console.error('Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî ÎèôÍ∏∞Ìôî Ïã§Ìå®:', error);
      setError('ÎèôÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.');
      showSnackbar('ÎèôÍ∏∞ÌôîÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'error');
    } finally {
      setIsLoading(false);
    }
  };

  // ÏùºÏ†ï Ï∂îÍ∞Ä Ìï∏Îì§Îü¨
  const handleAddEvent = () => {
    setEditingEvent(null);
    setDialogOpen(true);
  };

  // ÏùºÏ†ï ÏàòÏ†ï Ìï∏Îì§Îü¨
  const handleEditEvent = (event: CalendarEvent) => {
    setEditingEvent(event);
    setDialogOpen(true);
  };

  // ÏùºÏ†ï ÏÇ≠Ï†ú Ìï∏Îì§Îü¨
  const handleDeleteEvent = async (eventId: string) => {
    if (!window.confirm('Ï†ïÎßêÎ°ú Ïù¥ ÏùºÏ†ïÏùÑ ÏÇ≠Ï†úÌïòÏãúÍ≤†ÏäµÎãàÍπå?')) return;

    try {
      await CalendarService.deleteEvent(eventId);
      await fetchEvents();
      showSnackbar('ÏùºÏ†ïÏù¥ ÏÇ≠Ï†úÎêòÏóàÏäµÎãàÎã§.', 'success');
    } catch (error) {
      console.error('ÏùºÏ†ï ÏÇ≠Ï†ú Ïã§Ìå®:', error);
      showSnackbar('ÏùºÏ†ï ÏÇ≠Ï†úÏóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'error');
    }
  };

  // ÏùºÏ†ï Ï†ÄÏû• Ìï∏Îì§Îü¨
  const handleSaveEvent = async (eventData: EventFormData) => {
    setIsDialogLoading(true);
    try {
      const startDateTime = new Date(`${eventData.startDate}T${eventData.startTime}`);
      const endDateTime = new Date(`${eventData.endDate}T${eventData.endTime}`);

      const calendarEventData: GoogleCalendarEventRequest = {
        summary: eventData.summary,
        description: eventData.description,
        location: eventData.location,
        startDateTime: startDateTime.toISOString(),
        endDateTime: endDateTime.toISOString(),
      };

      if (editingEvent) {
        await CalendarService.updateEvent(editingEvent.id, calendarEventData);
        showSnackbar('ÏùºÏ†ïÏù¥ ÏàòÏ†ïÎêòÏóàÏäµÎãàÎã§.', 'success');
      } else {
        await CalendarService.addEvent(calendarEventData);
        showSnackbar('ÏùºÏ†ïÏù¥ Ï∂îÍ∞ÄÎêòÏóàÏäµÎãàÎã§.', 'success');
      }

      setDialogOpen(false);
      await fetchEvents();
    } catch (error) {
      console.error('ÏùºÏ†ï Ï†ÄÏû• Ïã§Ìå®:', error);
      showSnackbar('ÏùºÏ†ï Ï†ÄÏû•Ïóê Ïã§Ìå®ÌñàÏäµÎãàÎã§.', 'error');
    } finally {
      setIsDialogLoading(false);
    }
  };

  // Ïä§ÎÇµÎ∞î ÌëúÏãú Ìï®Ïàò
  const showSnackbar = (message: string, severity: 'success' | 'error') => {
    setSnackbar({ open: true, message, severity });
  };

  // Ïä§ÎÇµÎ∞î Îã´Í∏∞
  const handleSnackbarClose = () => {
    setSnackbar(prev => ({ ...prev, open: false }));
  };

  if (isLoading) {
    return (
      <Paper
        elevation={0}
        sx={{
          ...widgetPaperBase,
          background: widgetGradients.blue,
          height: '100%',
          display: 'flex',
          alignItems: 'center',
          justifyContent: 'center',
        }}
      >
        <CircularProgress size={40} />
      </Paper>
    );
  }

  // OAuth ÏÇ¨Ïö©ÏûêÍ∞Ä ÏïÑÎãå Í≤ΩÏö∞ Ï†ëÍ∑º Ï†úÌïú UI ÌëúÏãú
  if (!isOAuthUser) {
    return (
      <Paper
        elevation={0}
        sx={{
          ...widgetPaperBase,
          background: widgetGradients.blue,
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
          p: 2.5,
          borderRadius: 3,
          boxShadow: '0 10px 25px rgba(0,0,0,0.05)',
          position: 'relative',
          overflow: 'hidden',
        }}
      >
        {/* Î∞∞Í≤Ω Ïû•Ïãù */}
        <Box
          sx={{
            position: 'absolute',
            top: -50,
            right: -50,
            width: 200,
            height: 200,
            borderRadius: '50%',
            background:
              'radial-gradient(circle, rgba(233,245,255,0.7) 0%, rgba(233,245,255,0) 70%)',
            zIndex: 0,
          }}
        />

        {/* Ï†ëÍ∑º Ï†úÌïú Î©îÏãúÏßÄ */}
        <Box
          sx={{
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
            justifyContent: 'center',
            height: '100%',
            textAlign: 'center',
            position: 'relative',
            zIndex: 1,
          }}
        >
          <Alert
            severity="info"
            sx={{
              width: '100%',
              borderRadius: 2,
              '& .MuiAlert-icon': {
                fontSize: '2rem',
              },
            }}
          >
            <AlertTitle sx={{ fontSize: '1.1rem', fontWeight: 600 }}>
              <LockIcon sx={{ mr: 1, verticalAlign: 'middle' }} />
              Íµ¨Í∏Ä Î°úÍ∑∏Ïù∏ ÌïÑÏöî
            </AlertTitle>
            <Typography variant="body2" sx={{ mb: 2 }}>
              ÏùºÏ†ï Í¥ÄÎ¶¨ Í∏∞Îä•ÏùÄ Íµ¨Í∏Ä Í≥ÑÏ†ïÏúºÎ°ú Î°úÍ∑∏Ïù∏Ìïú ÏÇ¨Ïö©ÏûêÎßå Ïù¥Ïö©ÌïòÏã§ Ïàò ÏûàÏäµÎãàÎã§.
            </Typography>
            <Box sx={{ display: 'flex', flexDirection: 'column', gap: 1 }}>
              <Typography variant="body2" color="text.secondary">
                ‚Ä¢ Íµ¨Í∏Ä Ï∫òÎ¶∞ÎçîÏôÄ Ïó∞ÎèôÌïòÏó¨ ÏùºÏ†ïÏùÑ Í¥ÄÎ¶¨Ìï† Ïàò ÏûàÏäµÎãàÎã§
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ‚Ä¢ Ïã§ÏãúÍ∞Ñ ÎèôÍ∏∞ÌôîÎ°ú Î™®Îì† Í∏∞Í∏∞ÏóêÏÑú ÏùºÏ†ïÏùÑ ÌôïÏù∏Ìï† Ïàò ÏûàÏäµÎãàÎã§
              </Typography>
              <Typography variant="body2" color="text.secondary">
                ‚Ä¢ ÏïåÎ¶º ÏÑ§Ï†ïÏúºÎ°ú Ï§ëÏöîÌïú ÏùºÏ†ïÏùÑ ÎÜìÏπòÏßÄ ÎßàÏÑ∏Ïöî
              </Typography>
            </Box>
          </Alert>
        </Box>
      </Paper>
    );
  }

  return (
    <>
      <Paper
        elevation={0}
        sx={{
          ...widgetPaperBase,
          background: widgetGradients.blue,
          height: '100%',
          display: 'flex',
          flexDirection: 'column',
        }}
      >
        {/* Ìó§Îçî */}
        <Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between', mb: 2 }}>
          <Box sx={{ display: 'flex', alignItems: 'center' }}>
            <Avatar
              sx={{
                bgcolor: 'rgba(33, 150, 243, 0.2)',
                color: '#2196F3',
                width: 32,
                height: 32,
                mr: 1,
              }}
            >
              <EventIcon />
            </Avatar>
            <Typography variant="h6" fontWeight={600}>
              Îã§Í∞ÄÏò§Îäî ÏùºÏ†ï
            </Typography>
            <IconButton
              sx={{ display: { xs: 'inline-flex', md: 'none' }, ml: 1 }}
              size="small"
              onClick={() => setIsCollapsed(v => !v)}
            >
              <ExpandMoreIcon />
            </IconButton>
          </Box>
          <Box>
            <IconButton
              size="small"
              onClick={handleAddEvent}
              sx={{
                bgcolor: 'action.hover',
                mr: 1,
                '&:hover': { bgcolor: 'action.selected' },
              }}
            >
              <AddIcon fontSize="small" />
            </IconButton>
            <IconButton
              size="small"
              onClick={handleRefresh}
              sx={{
                bgcolor: 'action.hover',
                mr: 1,
                '&:hover': { bgcolor: 'action.selected' },
              }}
            >
              <RefreshIcon fontSize="small" />
            </IconButton>
            {isGoogleConnected && (
              <IconButton
                size="small"
                onClick={handleGoogleSync}
                sx={{
                  bgcolor: 'action.hover',
                  '&:hover': { bgcolor: 'action.selected' },
                }}
              >
                <SyncIcon fontSize="small" />
              </IconButton>
            )}
          </Box>
        </Box>

        {/* Ïù¥Î≤§Ìä∏ Î™©Î°ù */}
        <Box sx={{ flex: 1, overflowY: 'auto', minHeight: 0 }}>
          {error ? (
            <Box
              sx={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                height: '100%',
                textAlign: 'center',
                py: 4,
              }}
            >
              <Typography variant="body2" color="error" sx={{ mb: 2 }}>
                {error}
              </Typography>
              <Button
                variant="outlined"
                size="small"
                onClick={handleRefresh}
                sx={{ borderRadius: 2 }}
              >
                Îã§Ïãú ÏãúÎèÑ
              </Button>
            </Box>
          ) : !isGoogleConnected ? (
            <Box
              sx={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                height: '100%',
                textAlign: 'center',
                py: 4,
              }}
            >
              <GoogleIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2 }} />
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                Íµ¨Í∏Ä Ï∫òÎ¶∞Îçî Ïó∞ÎèôÏù¥ ÌïÑÏöîÌï©ÎãàÎã§
              </Typography>
              <Button
                variant="outlined"
                size="small"
                startIcon={<GoogleIcon />}
                onClick={handleRefresh}
                sx={{ borderRadius: 2 }}
              >
                Ïó∞Îèô ÌôïÏù∏
              </Button>
            </Box>
          ) : events.length > 0 ? (
            <List disablePadding>
              {events.map((event, index) => (
                <React.Fragment key={event.id}>
                  <EventItem event={event} onEdit={handleEditEvent} onDelete={handleDeleteEvent} />
                  {index < events.length - 1 && <Divider sx={{ my: 0.5 }} />}
                </React.Fragment>
              ))}
            </List>
          ) : (
            <Box
              sx={{
                display: 'flex',
                flexDirection: 'column',
                alignItems: 'center',
                justifyContent: 'center',
                height: '100%',
                textAlign: 'center',
                py: 4,
              }}
            >
              <EventIcon sx={{ fontSize: 48, color: 'text.secondary', mb: 2 }} />
              <Typography variant="body2" color="text.secondary" sx={{ mb: 2 }}>
                ÏòàÏ†ïÎêú ÏùºÏ†ïÏù¥ ÏóÜÏäµÎãàÎã§
              </Typography>
              <Button
                variant="outlined"
                size="small"
                startIcon={<AddIcon />}
                onClick={handleAddEvent}
                sx={{ borderRadius: 2 }}
              >
                ÏùºÏ†ï Ï∂îÍ∞Ä
              </Button>
            </Box>
          )}
        </Box>

        {/* ÌïòÎã® ÏöîÏïΩ */}
        {events.length > 0 && (
          <Box sx={{ mt: 2, pt: 2, borderTop: '1px solid', borderColor: 'divider' }}>
            <Typography variant="caption" color="text.secondary" textAlign="center">
              Îã§Ïùå {events.length}Í∞úÏùò ÏùºÏ†ï ‚Ä¢ Íµ¨Í∏Ä Ï∫òÎ¶∞ÎçîÏôÄ ÎèôÍ∏∞ÌôîÎê®
            </Typography>
          </Box>
        )}
      </Paper>

      {/* ÏùºÏ†ï Ï∂îÍ∞Ä/ÏàòÏ†ï Îã§Ïù¥ÏñºÎ°úÍ∑∏ */}
      <EventDialog
        open={dialogOpen}
        onClose={() => setDialogOpen(false)}
        onSave={handleSaveEvent}
        event={editingEvent}
        isLoading={isDialogLoading}
      />

      {/* Ïä§ÎÇµÎ∞î */}
      <Snackbar
        open={snackbar.open}
        autoHideDuration={3000}
        onClose={handleSnackbarClose}
        anchorOrigin={{ vertical: 'bottom', horizontal: 'center' }}
      >
        <Alert onClose={handleSnackbarClose} severity={snackbar.severity} sx={{ width: '100%' }}>
          {snackbar.message}
        </Alert>
      </Snackbar>
    </>
  );
};

export default UpcomingEventsWidget;
